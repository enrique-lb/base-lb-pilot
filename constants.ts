import { Bounty, BountyStatus } from './types';

// Base Network Constants
export const BASE_CHAIN_ID = 8453;
export const USDC_ADDRESS_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
export const BOUNTY_ESCROW_ADDRESS = '0xMockEscrowContractAddressOnBase';

// Mock Data for Initial State
export const INITIAL_BOUNTIES: Bounty[] = [
  {
    id: 101,
    githubIssueUrl: 'https://github.com/base-org/web3-ui/issues/42',
    title: 'Implement Dark Mode Toggle',
    description: 'We need a persistent dark mode toggle using Tailwind CSS and local storage. The current implementation flickers on load and does not respect system preferences.',
    amountUSDC: 150,
    status: BountyStatus.OPEN,
    maintainerAddress: '0x123...abc',
    tags: ['Frontend', 'React', 'UI/UX'],
    createdAt: '2023-10-25T10:00:00Z'
  },
  {
    id: 102,
    githubIssueUrl: 'https://github.com/base-org/node/issues/128',
    title: 'Optimize Gas Estimation Script',
    description: 'The current gas estimation script overestimates by 20%. Needs refactoring using Viem. This is causing users to overpay for transactions.',
    amountUSDC: 500,
    status: BountyStatus.IN_PROGRESS,
    maintainerAddress: '0x456...def',
    workerAddress: '0x789...ghi',
    tags: ['Backend', 'Web3', 'Optimization'],
    createdAt: '2023-10-26T14:30:00Z'
  },
  {
    id: 103,
    githubIssueUrl: 'https://github.com/base-org/indexer/issues/5',
    title: 'Fix Event Indexing Lag',
    description: 'Events are delayed by 5 blocks. Investigate RPC polling intervals and database indexing strategies to reduce latency.',
    amountUSDC: 1200,
    status: BountyStatus.OPEN,
    maintainerAddress: '0x123...abc',
    tags: ['Infrastructure', 'Database'],
    createdAt: '2023-10-27T09:15:00Z'
  }
];

// Developer Docs Constants
export const SOLIDITY_CONTRACT_CODE = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract BountyEscrow is Ownable {
    struct Bounty {
        address issuer;
        address worker;
        uint256 amount;
        bool isCompleted;
        bool isPaid;
    }

    IERC20 public usdc;
    mapping(uint256 => Bounty) public bounties;

    event BountyCreated(uint256 indexed bountyId, address indexed issuer, uint256 amount);
    event BountyCompleted(uint256 indexed bountyId, address indexed worker);
    event BountyPaid(uint256 indexed bountyId, address indexed worker, uint256 amount);

    constructor(address _usdcAddress) {
        usdc = IERC20(_usdcAddress);
    }

    function createBounty(uint256 _bountyId, uint256 _amount) external {
        require(usdc.transferFrom(msg.sender, address(this), _amount), "Transfer failed");
        bounties[_bountyId] = Bounty(msg.sender, address(0), _amount, false, false);
        emit BountyCreated(_bountyId, msg.sender, _amount);
    }

    function claimBounty(uint256 _bountyId) external {
        require(bounties[_bountyId].worker == address(0), "Already claimed");
        bounties[_bountyId].worker = msg.sender;
    }

    function completeBounty(uint256 _bountyId) external {
        require(msg.sender == bounties[_bountyId].worker, "Not the worker");
        bounties[_bountyId].isCompleted = true;
        emit BountyCompleted(_bountyId, msg.sender);
    }

    function releaseFunds(uint256 _bountyId) external {
        Bounty storage bounty = bounties[_bountyId];
        require(msg.sender == bounty.issuer, "Only issuer can release");
        require(bounty.isCompleted, "Not completed");
        require(!bounty.isPaid, "Already paid");

        bounty.isPaid = true;
        require(usdc.transfer(bounty.worker, bounty.amount), "Transfer failed");
        emit BountyPaid(_bountyId, bounty.worker, bounty.amount);
    }
}`;

export const SQL_SCHEMA_CODE = `create table public.bounties (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  title text null,
  description text null,
  status text null default 'OPEN'::text,
  amount_usdc numeric null,
  maintainer_address text null,
  worker_address text null,
  github_issue_url text null,
  tags text[] null,
  constraint bounties_pkey primary key (id)
);`;

export const API_ROUTE_CODE = `import type { NextApiRequest, NextApiResponse } from 'next';
import { supabase } from '../../lib/supabase';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { action, issue, repository } = req.body;

  if (action === 'closed' && issue.state === 'closed') {
    // Check if issue has a bounty associated
    const { data: bounty } = await supabase
        .from('bounties')
        .select('*')
        .eq('github_issue_url', issue.html_url)
        .single();

    if (bounty) {
        // Update bounty status
        await supabase
            .from('bounties')
            .update({ status: 'COMPLETED' })
            .eq('id', bounty.id);
            
        // Trigger smart contract event listener or notification
    }
  }

  res.status(200).json({ received: true });
}`;